@page "/game"
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject ass_di_stroid_frontend.Services.GameQueueService GameQueue
@inject ass_di_stroid_frontend.Api.Services.IHighScoreService HighScoreService
@implements IAsyncDisposable

<PageTitle>AssDiStroid The Escape - Playing</PageTitle>

<div class="game-wrapper">
  <div class="game-sidebar left-sidebar">
    <div class="sidebar-content">
      <button class="btn-escape" @onclick="GoHome">
        <span class="key-hint">ESC</span>
        <span>Exit Game</span>
      </button>

      <div class="team-display">
        <span class="team-label">TEAM</span>
        <span class="team-name">@teamName</span>
      </div>

      <div class="mode-display">
        <span class="mode-label">MODE</span>
        <span class="mode-value @(isTestMode ? "test" : "controller")">
          @(isTestMode ? "‚å®Ô∏è Test Mode" : "üéÆ Controller")
        </span>
      </div>

      @if (!isTestMode)
      {
        <div class="device-status">
          <span class="status-label">CONTROLLERS</span>
          <div class="controller-status">
            <span class="controller @(leftConnected ? "connected" : "disconnected")">
              ‚óÄ LEFT @(leftConnected ? "‚úì" : "‚óã")
            </span>
            <span class="controller @(rightConnected ? "connected" : "disconnected")">
              RIGHT ‚ñ∂ @(rightConnected ? "‚úì" : "‚óã")
            </span>
          </div>
        </div>
      }
    </div>
  </div>

  <div class="game-container" @ref="gameContainer">
    <canvas id="gameCanvas" @ref="canvasElement"></canvas>
  </div>

  <div class="game-sidebar right-sidebar">
    <div class="sidebar-content">
      <div class="score-panel">
        <div class="score-section">
          <span class="score-label">SCORE</span>
          <span class="score-value">@currentScore.ToString("N0")</span>
        </div>
        <div class="multiplier-section">
          <span class="multiplier-label">MULTIPLIER</span>
          <span class="multiplier-value">x @currentMultiplier.ToString("F1")</span>
        </div>
        <div class="highscore-section">
          <span class="highscore-label">BEST</span>
          <span class="highscore-value">@highScore.ToString("N0")</span>
        </div>
      </div>

      @if (nextTeamToBeat != null)
      {
        <div class="next-to-beat @(currentScore >= nextTeamToBeat.Score ? "passed" : "")">
          <div class="next-to-beat-header">
            <span class="next-icon">üéØ</span>
            <span class="next-label">@(currentScore >= nextTeamToBeat.Score ? "PASSED!" : "NEXT TO BEAT")</span>
          </div>
          <div class="next-team-name">@nextTeamToBeat.TeamName</div>
          <div class="next-score">@nextTeamToBeat.Score.ToString("N0")</div>
          <div class="score-diff">@((nextTeamToBeat.Score - currentScore).ToString("N0")) to go</div>
        </div>
      }

      <div class="phase-display">
        <span class="phase-icon">@(currentPhase == "earth" ? "üåç" : currentPhase == "mars" ? "üî¥" : "üåå")</span>
        <span class="phase-text">@(currentPhase == "earth" ? "Atmosphere" : currentPhase == "mars" ? "Mars" :
                    "Space")</span>
      </div>

      @if (activePowerUps.Any())
      {
        <div class="powerups-display">
          <span class="powerups-label">ACTIVE POWER-UPS</span>
          @foreach (var powerUp in activePowerUps)
          {
            <div class="powerup-item">
              <span class="powerup-icon">@GetPowerUpIcon(powerUp.Type)</span>
              <span class="powerup-name">@GetPowerUpName(powerUp.Type)</span>
              <span class="powerup-timer">@((powerUp.TimeRemaining / 10.0).ToString("F1"))s</span>
            </div>
          }
        </div>
      }
    </div>
  </div>
</div>

@code {
  [SupplyParameterFromQuery(Name = "team")]
  public string? TeamNameParam { get; set; }

  [SupplyParameterFromQuery(Name = "mode")]
  public string? ModeParam { get; set; }

  private ElementReference gameContainer;
  private ElementReference canvasElement;
  private DotNetObjectReference<Game>? dotNetRef;
  private bool initialized = false;
  private Timer? deviceCheckTimer;

  private string teamName = "Unknown";
  private bool isTestMode = true;
  private int currentScore = 0;
  private double currentMultiplier = 1.0;
  private int highScore = 0;
  private string currentPhase = "earth";

  // Next team to beat (Subway Surfers style)
  private ass_di_stroid_frontend.Api.Services.NextTeamInfo? nextTeamToBeat = null;
  private int lastFetchedScore = 0;

  // Device connection status
  private bool leftConnected = false;
  private bool rightConnected = false;

  // Active power-ups
  private List<PowerUpInfo> activePowerUps = new();
  private Timer? powerUpTimer;

  private class PowerUpInfo
  {
    public string Type { get; set; } = "";
    public int TimeRemaining { get; set; }
  }

  protected override void OnInitialized()
  {
    if (!string.IsNullOrWhiteSpace(TeamNameParam))
    {
      teamName = Uri.UnescapeDataString(TeamNameParam);
    }

    // Determine control mode
    isTestMode = ModeParam != "controller";

    // Set team name in queue service
    GameQueue.TeamName = teamName;

    // Subscribe to movement events from Arduino devices (only needed in controller mode)
    if (!isTestMode)
    {
      GameQueue.OnMovementChanged += HandleMovementChanged;
    }

    // Start timer to check device connections
    deviceCheckTimer = new Timer(CheckDeviceConnections, null, 0, 1000);

    // Start timer to update power-up timers
    powerUpTimer = new Timer(UpdatePowerUpTimers, null, 0, 100);
  }

  protected override async Task OnAfterRenderAsync(bool firstRender)
  {
    if (firstRender)
    {
      dotNetRef = DotNetObjectReference.Create(this);

      // Wait for canvas to be ready
      await Task.Delay(100);

      // Initialize and start the game with team name and mode
      var success = await JS.InvokeAsync<bool>("gameInterop.init", "gameCanvas", dotNetRef, teamName, isTestMode);
      if (success)
      {
        initialized = true;
        highScore = await JS.InvokeAsync<int>("gameInterop.getHighScore");

        // Fetch initial next team to beat
        _ = FetchNextTeamToBeatAsync(0);

        // Update game state to playing
        GameQueue.UpdateGameState(ass_di_stroid_frontend.Services.GameState.Playing);

        await JS.InvokeVoidAsync("gameInterop.start");
        StateHasChanged();
      }
    }
  }

  private async void HandleMovementChanged(ass_di_stroid_frontend.Services.DeviceDirection direction, bool isMoving)
  {
    if (!initialized) return;

    try
    {
      if (direction == ass_di_stroid_frontend.Services.DeviceDirection.Left)
      {
        await JS.InvokeVoidAsync("gameInterop.moveLeft", isMoving);
      }
      else
      {
        await JS.InvokeVoidAsync("gameInterop.moveRight", isMoving);
      }
    }
    catch (Exception ex)
    {
      Console.WriteLine($"Movement error: {ex.Message}");
    }
  }

  private void CheckDeviceConnections(object? state)
  {
    var devices = GameQueue.GetConnectedDevices();
    var newLeftConnected = devices.Any(d => d.Direction == ass_di_stroid_frontend.Services.DeviceDirection.Left);
    var newRightConnected = devices.Any(d => d.Direction == ass_di_stroid_frontend.Services.DeviceDirection.Right);

    if (newLeftConnected != leftConnected || newRightConnected != rightConnected)
    {
      leftConnected = newLeftConnected;
      rightConnected = newRightConnected;
      InvokeAsync(StateHasChanged);
    }
  }

  [JSInvokable]
  public void OnScoreUpdate(int score, double multiplier)
  {
    currentScore = score;
    currentMultiplier = multiplier;

    // Update queue service with current game state
    GameQueue.UpdateScore(score, multiplier, currentPhase);

    // Fetch next team to beat when score increases significantly or when we pass the current target
    bool shouldFetch = (nextTeamToBeat == null) ||
    (score >= nextTeamToBeat.Score) ||
    (score - lastFetchedScore >= 2000);

    if (shouldFetch)
    {
      _ = FetchNextTeamToBeatAsync(score);
    }

    StateHasChanged();
  }

  private async Task FetchNextTeamToBeatAsync(int score)
  {
    lastFetchedScore = score;
    var nextTeam = await HighScoreService.GetNextTeamAsync(score);
    if (nextTeam != null)
    {
      nextTeamToBeat = nextTeam;
      await InvokeAsync(StateHasChanged);
    }
  }

  [JSInvokable]
  public void OnPhaseChange(string phase)
  {
    currentPhase = phase;
    GameQueue.UpdateScore(currentScore, currentMultiplier, phase);
    StateHasChanged();
  }

  [JSInvokable]
  public void OnPowerUpCollected(string type, int duration)
  {
    var existingPowerUp = activePowerUps.FirstOrDefault(p => p.Type == type);
    if (existingPowerUp != null)
    {
      // Reset timer if already active (duration is in ms, convert to deciseconds)
      existingPowerUp.TimeRemaining = duration / 100;
    }
    else
    {
      // Add new power-up (duration is in ms, convert to deciseconds)
      activePowerUps.Add(new PowerUpInfo
      {
        Type = type,
        TimeRemaining = duration / 100
      });
    }
    StateHasChanged();
  }

  private void UpdatePowerUpTimers(object? state)
  {
    if (!activePowerUps.Any()) return;

    bool changed = false;
    for (int i = activePowerUps.Count - 1; i >= 0; i--)
    {
      activePowerUps[i].TimeRemaining--; // Decrement (timer runs every 100ms, we store in deciseconds)
      if (activePowerUps[i].TimeRemaining <= 0)
      {
        activePowerUps.RemoveAt(i);
        changed = true;
      }
    }

    if (changed || activePowerUps.Any())
    {
      InvokeAsync(StateHasChanged);
    }
  }

  private string GetPowerUpIcon(string type)
  {
    return type switch
    {
      "shield" => "üõ°Ô∏è",
      "nuclearThrust" => "‚ö°",
      "scoreBoost" => "‚≠ê",
      "slowMotion" => "üïê",
      _ => "‚ùì"
    };
  }

  private string GetPowerUpName(string type)
  {
    return type switch
    {
      "shield" => "Shield",
      "nuclearThrust" => "Nuclear Thrust",
      "scoreBoost" => "Score Boost",
      "slowMotion" => "Slow Motion",
      _ => "Unknown"
    };
  }

  [JSInvokable]
  public void OnGameRestart()
  {
    // Update game state to playing FIRST so Arduino heartbeats get correct state immediately
    GameQueue.UpdateGameState(ass_di_stroid_frontend.Services.GameState.Playing);

    // Reset next team to beat tracking
    nextTeamToBeat = null;
    lastFetchedScore = 0;
    _ = FetchNextTeamToBeatAsync(0);

    // Reset power-ups
    activePowerUps.Clear();

    // Reset Arduino movement states when game restarts
    // This ensures no "stuck" button states from previous game
    if (!isTestMode)
    {
      GameQueue.ClearMovementStates();
    }
  }

  [JSInvokable]
  public void OnGameOver(int score, int newHighScore)
  {
    currentScore = score;
    highScore = newHighScore;
    GameQueue.UpdateGameState(ass_di_stroid_frontend.Services.GameState.GameOver);

    // Submit score to highscore API
    if (!string.IsNullOrWhiteSpace(teamName) && score > 0)
    {
      _ = Task.Run(async () =>
      {
        var success = await HighScoreService.SubmitScoreAsync(teamName, score);
        // Fire and forget - logging handled in service
      });
    }

    StateHasChanged();
  }

  private async Task GoHome()
  {
    if (initialized)
    {
      await JS.InvokeVoidAsync("gameInterop.stop");
    }

    // Reset queue when leaving game
    GameQueue.ResetQueue();
    Navigation.NavigateTo("/");
  }

  public async ValueTask DisposeAsync()
  {
    // Unsubscribe from events
    GameQueue.OnMovementChanged -= HandleMovementChanged;
    deviceCheckTimer?.Dispose();
    powerUpTimer?.Dispose();

    if (initialized)
    {
      try
      {
        await JS.InvokeVoidAsync("gameInterop.dispose");
      }
      catch (JSDisconnectedException)
      {
        // Circuit already disconnected, safe to ignore
      }
    }
    dotNetRef?.Dispose();
  }
}